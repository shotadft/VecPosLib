from typing import (
    Generic,
    Iterator,
    List,
    Optional,
    Sequence,
    Tuple,
    Union,
    overload,
)
from ..common import (
    T,
    ArrayType,
    CoordinateName,
    Number,
    VectorDimension,
)
from ..positionlib.position import Position

class Vector(Generic[T]):
    def __init__(self, data: Union[Sequence[T], Position[T]]) -> None: ...
    @classmethod
    def from_seq(cls, data: Sequence[T]) -> "Vector[T]": ...
    @property
    def dimension(self) -> VectorDimension: ...
    @property
    def ndim(self) -> int: ...
    @property
    def x(self) -> T: ...
    @property
    def y(self) -> T: ...
    @property
    def z(self) -> T: ...
    @property
    def w(self) -> T: ...
    def _create(self, data: Sequence[T]) -> "Vector[T]": ...
    def _get_coord(self, index: int) -> T: ...
    def _from_arr(self, arr: ArrayType) -> "Vector[T]": ...
    def __setattr__(self, name: str, value: object) -> None: ...
    def _target_type(self): ...
    def _cast(self, v): ...
    def _cast_coords(self, coords: ArrayType) -> List[T]: ...
    def _cast_val(self, value: float) -> T: ...
    def get_vec(self) -> ArrayType: ...
    def _inv_coords(self) -> List[float]: ...
    def _refl_coords(self, normal: "Vector[T]") -> List[float]: ...
    def _proj_coords(self, other: "Vector[T]") -> List[float]: ...
    def _norm(self, arr: ArrayType) -> float: ...
    def _dot(self, a: ArrayType, b: ArrayType) -> float: ...
    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, ...]: ...
    def astype(self, dtype: type) -> "Vector[float]": ...
    def __add__(self, other: "Vector[T]") -> "Vector[T]": ...
    def __sub__(self, other: "Vector[T]") -> "Vector[T]": ...
    def __mul__(self, scalar: Number) -> "Vector[T]": ...
    def __rmul__(self, scalar: Number) -> "Vector[T]": ...
    def clamp(self, min_val: Number, max_val: Number) -> "Vector[T]": ...
    def abs(self) -> "Vector[T]": ...
    def inverse(self) -> "Vector[T]": ...
    def normalize(self) -> "Vector[float]": ...
    def reflect(self, normal: "Vector[T]") -> "Vector[float]": ...
    def project(self, other: "Vector[T]") -> "Vector[float]": ...
    def lerp(self, other: "Vector[T]", t: float) -> "Vector[float]": ...
    def dot(self, other: "Vector[T]") -> float: ...
    def norm(self) -> float: ...
    def distance(self, other: "Vector[T]") -> float: ...
    def manhattan(self, other: "Vector[T]") -> T: ...
    def angle_between(self, other: "Vector[T]") -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def get_coordinate(self, name: CoordinateName) -> T: ...
    def __getitem__(self, idx: int) -> T: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __repr__(self) -> str: ...

class Vec2(Vector[T]):
    @overload
    def __init__(self, x: Position[T], y: None = None) -> None: ...
    @overload
    def __init__(self, x: T, y: T) -> None: ...
    def __init__(self, x: Union[T, Position[T]], y: Optional[T] = None) -> None: ...
    def cross(self, other: "Vec2[T]") -> T: ...

class Vec3(Vector[T]):
    @overload
    def __init__(self, x: Position[T], y: None = None, z: None = None) -> None: ...
    @overload
    def __init__(self, x: T, y: T, z: T) -> None: ...
    def __init__(
        self, x: Union[T, Position[T]], y: Optional[T] = None, z: Optional[T] = None
    ) -> None: ...
    def cross(self, other: "Vec3[T]") -> "Vec3[float]": ...

class Vec4(Vector[T]):
    @overload
    def __init__(
        self, x: Position[T], y: None = None, z: None = None, w: None = None
    ) -> None: ...
    @overload
    def __init__(self, x: T, y: T, z: T, w: T) -> None: ...
    def __init__(
        self,
        x: Union[T, Position[T]],
        y: Optional[T] = None,
        z: Optional[T] = None,
        w: Optional[T] = None,
    ) -> None: ...
