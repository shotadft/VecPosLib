from typing import (
    TypeVar,
    Generic,
    Union,
    List,
    Tuple,
    Sequence,
    Iterator,
    Optional,
    overload,
)
from ..positionlib.position import Position

Number = Union[float, int]
T = TypeVar("T", bound=Number)

class Vector(Generic[T]):
    def __init__(self, data: Union[Sequence[T], "Position[T]"]) -> None: ...
    @property
    def ndim(self) -> int: ...
    def to_list(self) -> List[T]: ...
    def to_tuple(self) -> Tuple[T, ...]: ...
    def norm(self) -> float: ...
    def normalize(self) -> "Vector[float]": ...
    def dot(self, other: "Vector[T]") -> float: ...
    def __add__(self, other: "Vector[T]") -> "Vector[float]": ...
    def __sub__(self, other: "Vector[T]") -> "Vector[float]": ...
    def __repr__(self) -> str: ...
    def __getitem__(self, idx: int) -> T: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __mul__(self, scalar: Number) -> "Vector[float]": ...
    def __rmul__(self, scalar: Number) -> "Vector[float]": ...
    def distance(self, other: "Vector[T]") -> float: ...
    def manhattan(self, other: "Vector[T]") -> T: ...
    def lerp(self, other: "Vector[T]", t: float) -> "Vector[float]": ...
    def clamp(self, min_val: Number, max_val: Number) -> "Vector[float]": ...
    def abs(self) -> "Vector[float]": ...
    def sum(self) -> T: ...
    def prod(self) -> T: ...
    def min(self) -> T: ...
    def max(self) -> T: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> "Vector[float]": ...
    def astype(self, dtype: type) -> "Vector[float]": ...
    def reflect(self, normal: "Vector[T]") -> "Vector[float]": ...
    def project(self, other: "Vector[T]") -> "Vector[float]": ...
    def angle_between(self, other: "Vector[T]") -> float: ...
    def _get_coord_property(self, index: int) -> T: ...
    def _calc_inverse_coords(self) -> List[float]: ...
    def _calc_reflect_coords(self, normal: "Vector[T]") -> List[float]: ...
    def _calc_project_coords(self, other: "Vector[T]") -> List[float]: ...

class Vec2(Vector[T]):
    @overload
    def __init__(self, x: Position[T], y: None = ...) -> None: ...
    @overload
    def __init__(self, x: T, y: T) -> None: ...
    def __init__(self, x: Union[T, Position[T]], y: Optional[T] = None): ...
    @property
    def x(self) -> T: ...
    @property
    def y(self) -> T: ...
    def cross(self, other: "Vec2[T]") -> T: ...
    def angle(self, other: "Vec2[T]") -> float: ...
    def inverse(self) -> "Vec2[float]": ...
    def reflect(self, normal: "Vec2[T]") -> "Vec2[float]": ...  # type: ignore[override]
    def project(self, other: "Vec2[T]") -> "Vec2[float]": ...  # type: ignore[override]

class Vec3(Vector[T]):
    @overload
    def __init__(self, x: Position[T], y: None = None, z: None = None) -> None: ...
    @overload
    def __init__(self, x: T, y: T, z: T) -> None: ...
    def __init__(
        self, x: Union[T, Position[T]], y: Optional[T] = None, z: Optional[T] = None
    ): ...
    @property
    def x(self) -> T: ...
    @property
    def y(self) -> T: ...
    @property
    def z(self) -> T: ...
    def cross(self, other: "Vec3[T]") -> "Vec3[float]": ...
    def angle(self, other: "Vec3[T]") -> float: ...
    def inverse(self) -> "Vec3[float]": ...
    def reflect(self, normal: "Vec3[T]") -> "Vec3[float]": ...  # type: ignore[override]
    def project(self, other: "Vec3[T]") -> "Vec3[float]": ...  # type: ignore[override]

class Vec4(Vector[T]):
    @overload
    def __init__(
        self, x: Position[T], y: None = None, z: None = None, w: None = None
    ) -> None: ...
    @overload
    def __init__(self, x: T, y: T, z: T, w: T) -> None: ...
    def __init__(
        self,
        x: Union[T, Position[T]],
        y: Optional[T] = None,
        z: Optional[T] = None,
        w: Optional[T] = None,
    ): ...
    @property
    def x(self) -> T: ...
    @property
    def y(self) -> T: ...
    @property
    def z(self) -> T: ...
    @property
    def w(self) -> T: ...
    def inverse(self) -> "Vec4[float]": ...
    def reflect(self, normal: "Vec4[T]") -> "Vec4[float]": ...  # type: ignore[override]
    def project(self, other: "Vec4[T]") -> "Vec4[float]": ...  # type: ignore[override]
