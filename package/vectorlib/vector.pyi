from typing import TypeVar, Generic, Union, List, Tuple, Sequence

Number = Union[float, int]
T = TypeVar("T", bound=Number)

class Vector(Generic[T]):
    def __init__(self, data: Sequence[T]) -> None: ...
    @property
    def ndim(self) -> int: ...
    def to_list(self) -> List[Number]: ...
    def to_tuple(self) -> Tuple[Number, ...]: ...
    def norm(self) -> float: ...
    def normalize(self) -> "Vector[float]": ...
    def dot(self, other: "Vector[T]") -> float: ...
    def __add__(self, other: "Vector[T]") -> "Vector[T]": ...
    def __sub__(self, other: "Vector[T]") -> "Vector[T]": ...
    def __repr__(self) -> str: ...
    def __getitem__(self, idx: int) -> Number: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __eq__(self, other: object) -> bool: ...
    def __mul__(self, scalar: Number) -> "Vector[float]": ...
    def __rmul__(self, scalar: Number) -> "Vector[float]": ...
    def distance(self, other: "Vector[T]") -> float: ...
    def manhattan(self, other: "Vector[T]") -> Number: ...
    def lerp(self, other: "Vector[T]", t: float) -> "Vector[float]": ...
    def clamp(self, min_val: Number, max_val: Number) -> "Vector[T]": ...
    def abs(self) -> "Vector[T]": ...
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> "Vector[float]": ...
    def astype(self, dtype: type) -> "Vector[float]": ...
    def reflect(self, normal: "Vector[T]") -> "Vector[float]": ...
    def project(self, other: "Vector[T]") -> "Vector[float]": ...
    def angle_between(self, other: "Vector[T]") -> float: ...

class Vec2(Vector[T]):
    def __init__(self, x: T, y: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    def cross(self, other: "Vec2[T]") -> Number: ...
    def angle(self, other: "Vec2[T]") -> float: ...
    def distance(self, other: "Vec2[T]") -> float: ... # type: ignore[override]
    def manhattan(self, other: "Vec2[T]") -> Number: ... # type: ignore[override]
    def lerp(self, other: "Vec2[T]", t: float) -> "Vec2[float]": ... # type: ignore[override]
    def clamp(self, min_val: Number, max_val: Number) -> "Vec2[float]": ... # type: ignore[override]
    def abs(self) -> "Vec2[float]": ... # type: ignore[override]
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> "Vec2[float]": ...
    def reflect(self, normal: "Vec2[T]") -> "Vec2[float]": ... # type: ignore[override]
    def project(self, other: "Vec2[T]") -> "Vec2[float]": ... # type: ignore[override]
    def angle_between(self, other: "Vec2[T]") -> float: ... # type: ignore[override]
    def astype(self, dtype: type) -> "Vec2[float]": ...

class Vec3(Vector[T]):
    def __init__(self, x: T, y: T, z: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    @property
    def z(self) -> Number: ...
    def cross(self, other: "Vec3[T]") -> "Vec3[float]": ...
    def angle(self, other: "Vec3[T]") -> float: ...
    def distance(self, other: "Vec3[T]") -> float: ... # type: ignore[override]
    def manhattan(self, other: "Vec3[T]") -> Number: ... # type: ignore[override]
    def lerp(self, other: "Vec3[T]", t: float) -> "Vec3[float]": ... # type: ignore[override]
    def clamp(self, min_val: Number, max_val: Number) -> "Vec3[float]": ... # type: ignore[override]
    def abs(self) -> "Vec3[float]": ... # type: ignore[override]
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> "Vec3[float]": ...
    def reflect(self, normal: "Vec3[T]") -> "Vec3[float]": ... # type: ignore[override]
    def project(self, other: "Vec3[T]") -> "Vec3[float]": ... # type: ignore[override]
    def angle_between(self, other: "Vec3[T]") -> float: ... # type: ignore[override]
    def astype(self, dtype: type) -> "Vec3[float]": ...

class Vec4(Vector[T]):
    def __init__(self, x: T, y: T, z: T, w: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    @property
    def z(self) -> Number: ...
    @property
    def w(self) -> Number: ...
    def distance(self, other: "Vec4[T]") -> float: ... # type: ignore[override]
    def manhattan(self, other: "Vec4[T]") -> Number: ... # type: ignore[override]
    def lerp(self, other: "Vec4[T]", t: float) -> "Vec4[float]": ... # type: ignore[override]
    def clamp(self, min_val: Number, max_val: Number) -> "Vec4[float]": ... # type: ignore[override]
    def abs(self) -> "Vec4[float]": ... # type: ignore[override]
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> "Vec4[float]": ...
    def reflect(self, normal: "Vec4[T]") -> "Vec4[float]": ... # type: ignore[override]
    def project(self, other: "Vec4[T]") -> "Vec4[float]": ... # type: ignore[override]
    def angle_between(self, other: "Vec4[T]") -> float: ... # type: ignore[override]
    def astype(self, dtype: type) -> "Vec4[float]": ...
