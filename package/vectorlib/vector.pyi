from typing import TypeVar, Generic, Union, List, Tuple, Sequence

Number = Union[float, int]
T = TypeVar('T', bound=Number)

class Vector(Generic[T]):
    def __init__(self, data: Sequence[T]) -> None: ...
    @property
    def ndim(self) -> int: ...
    def to_list(self) -> List[Number]: ...
    def to_tuple(self) -> Tuple[Number, ...]: ...
    def norm(self) -> float: ...
    def normalize(self) -> 'Vector[float]': ...
    def dot(self, other: 'Vector[T]') -> float: ...
    def __add__(self, other: 'Vector[T]') -> 'Vector[T]': ...
    def __sub__(self, other: 'Vector[T]') -> 'Vector[T]': ...
    def __repr__(self) -> str: ...
    def __getitem__(self, idx: int) -> Number: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __eq__(self, other: object) -> bool: ...
    def __mul__(self, scalar: Number) -> 'Vector[float]': ...
    def __rmul__(self, scalar: Number) -> 'Vector[float]': ...

class Vec2(Vector[T]):
    def __init__(self, x: T, y: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    def cross(self, other: 'Vec2[T]') -> Number: ...
    def angle(self, other: 'Vec2[T]') -> float: ...
    def distance(self, other: 'Vec2[T]') -> float: ...
    def manhattan(self, other: 'Vec2[T]') -> Number: ...
    def lerp(self, other: 'Vec2[T]', t: float) -> 'Vec2[float]': ...
    def clamp(self, min_val: Number, max_val: Number) -> 'Vec2[float]': ...
    def abs(self) -> 'Vec2[float]': ...
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> 'Vec2[float]': ...
    def reflect(self, normal: 'Vec2[T]') -> 'Vec2[float]': ...
    def project(self, other: 'Vec2[T]') -> 'Vec2[float]': ...
    def angle_between(self, other: 'Vec2[T]') -> float: ...
    def astype(self, dtype: type) -> 'Vec2[float]': ...
    def normalize(self) -> 'Vec2[float]': ...

class Vec3(Vector[T]):
    def __init__(self, x: T, y: T, z: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    @property
    def z(self) -> Number: ...
    def cross(self, other: 'Vec3[T]') -> 'Vec3[float]': ...
    def angle(self, other: 'Vec3[T]') -> float: ...
    def distance(self, other: 'Vec3[T]') -> float: ...
    def manhattan(self, other: 'Vec3[T]') -> Number: ...
    def lerp(self, other: 'Vec3[T]', t: float) -> 'Vec3[float]': ...
    def clamp(self, min_val: Number, max_val: Number) -> 'Vec3[float]': ...
    def abs(self) -> 'Vec3[float]': ...
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> 'Vec3[float]': ...
    def reflect(self, normal: 'Vec3[T]') -> 'Vec3[float]': ...
    def project(self, other: 'Vec3[T]') -> 'Vec3[float]': ...
    def angle_between(self, other: 'Vec3[T]') -> float: ...
    def astype(self, dtype: type) -> 'Vec3[float]': ...
    def normalize(self) -> 'Vec3[float]': ...

class Vec4(Vector[T]):
    def __init__(self, x: T, y: T, z: T, w: T) -> None: ...
    @property
    def x(self) -> Number: ...
    @property
    def y(self) -> Number: ...
    @property
    def z(self) -> Number: ...
    @property
    def w(self) -> Number: ...
    def distance(self, other: 'Vec4[T]') -> float: ...
    def manhattan(self, other: 'Vec4[T]') -> Number: ...
    def lerp(self, other: 'Vec4[T]', t: float) -> 'Vec4[float]': ...
    def clamp(self, min_val: Number, max_val: Number) -> 'Vec4[float]': ...
    def abs(self) -> 'Vec4[float]': ...
    def sum(self) -> Number: ...
    def prod(self) -> Number: ...
    def min(self) -> Number: ...
    def max(self) -> Number: ...
    def is_unit(self, tol: float = ...) -> bool: ...
    def inverse(self) -> 'Vec4[float]': ...
    def reflect(self, normal: 'Vec4[T]') -> 'Vec4[float]': ...
    def project(self, other: 'Vec4[T]') -> 'Vec4[float]': ...
    def angle_between(self, other: 'Vec4[T]') -> float: ...
    def astype(self, dtype: type) -> 'Vec4[float]': ...
    def normalize(self) -> 'Vec4[float]': ...
